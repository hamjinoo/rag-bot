# 8주 완주 로드맵

각 주차는 **목표 → 핵심 작업 → 산출물 → 완료 기준** 순으로 구성됩니다. 평일 2~3시간, 주말 4~6시간 기준으로 설계되었습니다.

## Week 1 — 기반 세팅 & 파이프라인 뼈대
- **목표**: 업로드→임베딩→검색→답변의 기본 흐름 구축
- **핵심 작업**
  - FastAPI 엔드포인트 `/upload`, `/ask` 작성
  - PDF/Docx/CSV 텍스트 추출 + 청크 분할(400~800 tokens, overlap 100)
  - OpenAI 임베딩 → Chroma 색인
  - 답변에 문서명·페이지·URL 포함하도록 프롬프트 구성
  - `.env.example` 에 API 키, DB 경로 명시
- **산출물**
  - GitHub 첫 커밋 (README: 설치법·실행법 포함)
  - 샘플 문서 2~3개 업로드 및 테스트 로그
- **완료 기준**
  - REST 요청에서 출처 포함 답변 반환
  - 로컬 Chroma DB에 벡터 10개 이상 적재
- **실습 순서**
  1. `python -m venv .venv`로 가상환경 생성, `pip install -r requirements.txt`
  2. `app/main.py`에 FastAPI 기본 앱과 `/ping` 헬스체크 작성 → `uvicorn` 실행으로 확인
  3. `app/pipelines.py`에서 PDF 1개를 `data/`에 두고, 청크 분할 결과를 `print`로 점검
  4. `/upload`에서 받은 파일을 `data/uploads/`에 저장하고, 파이프라인 호출 → Chroma에 `collection.count()`로 삽입 수 체크
  5. `/ask` 호출을 `curl` 또는 VS Code Thunder Client로 테스트, 응답 JSON에 `sources` 필드 포함 여부 검증

> **학습 자료**: FastAPI 공식 튜토리얼(https://fastapi.tiangolo.com/tutorial/) 1~4장, Chroma 빠른 시작

## Week 2 — 텔레그램 봇 연동
- **목표**: 텔레그램에서 질문 → 서버 → 답변까지 동작
- **핵심 작업**
  - BotFather 토큰 발급, `.env` 반영
  - `/telegram/webhook` FastAPI 라우트 구현
  - 메시지 이벤트 → RAG 파이프라인 재사용
  - 출처 표시를 메시지 하단 bullet로 정리
  - 1~2분 무음 데모 영상 촬영(화면 녹화 + 자막)
- **산출물**
  - Demo #1 (텔레그램) 유튜브 비공개 링크
  - 텔레그램 명령어/운영 가이드 초안
- **완료 기준**
  - 텔레그램 대화 5건 이상 테스트, 오류 로그 없음
  - README에 텔레그램 설정 절차가 정리됨
- **실습 순서**
  1. BotFather에서 `/setprivacy`로 봇 프라이버시 모드 OFF (대화 전부 수신용)
  2. `ngrok http 8000`으로 임시 HTTPS 주소 확보 후 `.env`의 `TELEGRAM_WEBHOOK_URL` 갱신
  3. `/telegram/webhook` 라우트 구현 → 텔레그램 API `getWebhookInfo`로 설정 정상 여부 확인
  4. 채팅방에서 FAQ 3개, 문서 없는 질문 2개 테스트하여 응답 포맷 검증
  5. OBS/SimpleScreenRecorder로 화면 녹화 → 무음으로 편집, 자막은 캡션 툴(Zubtitle 등) 사용

## Week 3 — 웹 UI 데모
- **목표**: 간단 웹 폼으로 질문/답변 및 출처 카드 표시
- **핵심 작업**
  - `web/index.html` 에 입력 폼, 로딩 스피너, 에러 토스트 구현
  - Fetch API로 `/ask` 호출 → JSON 처리
  - 답변 영역에 마크다운 렌더 혹은 간단 HTML 변환
  - 출처 리스트(문서명·페이지·링크) 하단 카드로 노출
  - 스크린샷 3장 캡처(질문/답변/출처, 에러 케이스 포함)
- **산출물**
  - Demo #2 (웹) 이미지·클립
  - UI/UX 간단 설명 문단 README 추가
- **완료 기준**
  - 브라우저 콘솔 에러 없음
  - 주요 시나리오(정상/출처 없음/에러) 모두 캡처
- **실습 순서**
  1. `web/index.html`에 기본 레이아웃 작성 → `Live Server` 혹은 `python -m http.server`로 미리보기
  2. Fetch API로 `/ask` 호출 → 네트워크 탭에서 Request/Response 확인
  3. 답변 본문을 `<pre>`나 마크다운 렌더러(`marked.js`)로 표현, 출처는 `<ol>` 리스트 구성
  4. 에러 발생 시 토스트 컴포넌트 표시(Timeout, 400, 500 각각 테스트)
  5. 크롬 DevTools로 모바일 뷰 확인 후 캡처, 정상/에러/출처 없음 상태 스크린샷 저장

## Week 4 — 정확도 & 가드레일
- **목표**: 헛소리 최소화, 정확도 지표 도입
- **핵심 작업**
  - 검색 설정: `top_k=5`, `mmr=True`, 최소 유사도 0.75
  - 컨텍스트 토큰 제한, “출처 없는 내용 금지” 프롬프트 규칙
  - CSV 평가셋 제작(질문/정답/기대 출처)
  - 파이프라인 스크립트로 정답률·근거 일치율 계산
  - 가드레일 실패 케이스 대응 메시지 작성
- **산출물**
  - 정확도 리포트(정량 + 개선 이력)
  - 가드레일 정책 정리 문서
- **완료 기준**
  - 평가 스크립트 실행 로그, 정확도 기준(예: 75% 이상)
  - README에 품질 관리 섹션 추가
- **실습 순서**
  1. `data/eval.csv`에 20문항 이상의 평가셋 작성(질문/정답/출처)
  2. `scripts/evaluate.py`에서 파이프라인을 호출하여 `precision`, `recall` 간단 계산
  3. 임계치(`score_threshold`)를 0.65~0.85 범위에서 조정하며 결과 비교 → 그래프 저장
  4. 실패 사례를 모아 “헛소리 대응 스크립트” 문단을 README에 작성
  5. 개선 전후 정확도 수치를 `docs/roadmap/week01-08.md` Week 4 섹션에도 업데이트

## Week 5 — 카카오톡 챗봇
- **목표**: 카카오 i 오픈빌더와 RAG 파이프라인 연동
- **핵심 작업**
  - 카카오톡 채널 생성 후 스킬 서버 URL 등록
  - 시그니처 검증(해시 값 비교) 구현
  - 카카오 JSON 포맷 ↔ 내부 포맷 변환 레이어 작성
  - 텔레그램과 공유 가능한 서비스 로직 모듈화
  - 데모 영상·캡처 확보(사내 공유용)
- **산출물**
  - Demo #3 (카카오) 영상/캡처
  - 운영 문서(스킬 서버 배포, 검증 방법)
- **완료 기준**
  - 카카오 테스트 채널에서 5건 이상 질의 성공
  - 시그니처 검증 실패 시 403 처리 로그 확인
- **실습 순서**
  1. 오픈빌더에서 시나리오(웰컴/Default Fallback) 생성, 스킬 연결
  2. `kakao_router.py`에 시그니처 검증 + 포맷 변환 로직 구현 후 `pytest` 혹은 단위 테스트로 검증
  3. 오픈빌더 테스트 콘솔로 5개 시나리오(정상/출처 없음/에러/금칙어/권한 필요) 수행
  4. 데모 영상은 모바일 미러링 앱(Your Phone, Scrcpy)을 활용해 촬영
  5. 카카오 가이드 문서(문서ID, 서버 IP 등)를 노션 “고객용 문서” 섹션에 정리

## Week 6 — 권한·로그·비용 모니터링
- **목표**: 기업 납품 수준의 신뢰 요소 추가
- **핵심 작업**
  - JWT 기반 로그인, 사용자/권한 테이블 설계
  - 문서 메타데이터에 접근 권한 필드 추가(팀/직급)
  - SQLite/Postgres에 요청/응답/토큰/비용 로깅
  - `/admin` 페이지에서 일별 사용량 그래프(Lite chart)
  - 비용 계산 로직(OpenAI 가격표 기준) 반영
- **산출물**
  - 관리자 페이지 캡처, 로그 스키마 다이어그램
  - 운영 보고서 템플릿 (주간/월간)
- **완료 기준**
  - 특정 역할 계정으로 제한 문서 접근 차단 확인
  - 일별 비용 그래프 스크린샷 확보
- **실습 순서**
  1. `alembic` 또는 `sqlalchemy`로 스키마 생성 → 로컬 SQLite로 먼저 검증
  2. 로그인 API(`/auth/login`) → JWT 발급 → 프론트에서 Bearer 토큰 저장(로컬스토리지)
  3. 권한이 다른 계정 2개를 만들고 동일 질문에 대해 문서 접근 차이 확인
  4. `requests` 테이블에 더미 데이터 30건 삽입 후 대시보드에서 차트 동작 확인
  5. 일별 비용 그래프를 PNG로 저장하여 README 품질/운영 섹션에 첨부

## Week 7 — 배포 & 패키징
- **목표**: 언제든 납품 가능한 배포 상태 확보
- **핵심 작업**
  - `Dockerfile`, `docker-compose.yml` 작성
  - Render/Fly.io/Cloud Run 중 택1 배포 (스테이징 URL)
  - `.env` 환경 분리(로컬/스테이징/프로덕션)
  - README에 배포 절차, 롤백 방법 문서화
  - 보안 점검(https, API 키 보호, 로그 마스킹)
- **산출물**
  - 스테이징 URL 및 배포 체크리스트
  - 설치 가이드 PDF 2p (고객 공유용)
- **완료 기준**
  - 배포 자동화 스크립트 실행 성공 로그
  - 스테이징에서 텔레그램/웹/카카오 시연 가능
- **실습 순서**
  1. `Dockerfile`로 로컬 빌드(`docker build -t rag-bot .`) → 컨테이너 실행 테스트
  2. `docker-compose.yml`에 FastAPI + Chroma + Postgres(선택) 정의
  3. 선택한 클라우드(Render/Fly/Cloud Run)에 환경변수와 볼륨 구성 후 배포
  4. 배포 URL을 텔레그램/카카오 설정에 반영하여 실서버 테스트
  5. 고객 전달용 설치/운영 문서를 Google Docs 혹은 Notion → PDF로 저장

## Week 8 — 노션 소개·가격표·수주 준비
- **목표**: 즉시 계약 가능한 영업 자료 완성
- **핵심 작업**
  - 노션 페이지: 문제→해결→데모→정확도→보안→가격→FAQ→연락처
  - 가격 템플릿(Lite/Pro/Enterprise) 및 견적서/계약서 샘플
  - 숨고·크몽·위시켓 등록용 소개 문구 작성
  - 포트폴리오 영상/이미지 정리, 캘린더 예약 링크 설정
  - 후속 고객 문의 대응 스크립트 마련
- **산출물**
  - 노션 완성본, 가격표, 제안서·계약서 템플릿
  - 플랫폼 게시 캡처/링크
- **완료 기준**
  - 노션 페이지 공유 링크, PDF 백업 확인
  - 3개 플랫폼에 게시 완료, 검수 통과
- **실습 순서**
  1. 노션 템플릿을 복제해 포트폴리오용 페이지 작성, 각 섹션에 데모/리포트 링크 삽입
  2. 가격표·제안서·계약서 템플릿을 Google Docs/PPT로 제작 후 PDF 변환
  3. 숨고·크몽·위시켓에 게시 글 작성(썸네일, 태그, 요약 포함) → 검수 기간 기록
  4. 캘린더 예약 툴(Cal.com) 계정 생성 → 노션 CTA 버튼에 연동
  5. 문의 대응 스크립트와 FAQ를 Notion Database로 만들어 반복 활용

## 참고
- **일일 루틴**: 작업 후 반드시 로그/노션 업데이트 → 다음날 To-do 정리
- **주간 리뷰**: 데모 링크 최신 상태인지, 정확도/비용 지표 변화를 점검
- **확장 아이디어**: Notion/DB 커넥터, Tool Use, 피드백 루프, 음성 인터페이스 등은 별도 브랜치에 정리 후 고객 미팅용으로 활용하세요.

